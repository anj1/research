<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="http://localhost:1313/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">

<meta name="description" content=""/>



<title>
    
    Second Post | A Nejati&#39;s blog
    
</title>

<link rel="canonical" href="http://localhost:1313/posts/second-post/"/>

<meta property="og:url" content="http://localhost:1313/posts/second-post/">
  <meta property="og:site_name" content="A Nejati&#39;s blog">
  <meta property="og:title" content="Second Post">
  <meta property="og:description" content="Finely Crafted State Spaces for Fast Attention # Alireza Nejati
Abstract # Linear-time transformers have emerged as a promising solution to the quadratic cost of standard self-attention, but existing methods face a difficult trade-off. Stochastic approaches introduce variance, while deterministic polynomial kernels like Power Attention offer only coarse, exponential control over their state size, limiting their practicality. We introduce Factorized Polynomial Attention (FPA), a new attention mechanism that is both exact and offers fine-grained, continuous control over its state space. FPA constructs a degree-$n$ polynomial kernel by factorizing it into a product of $n$ inner products in lower-dimensional projected spaces. This formulation allows the state size to be adjusted by tuning the projection dimensions, smoothly navigating the trade-off between memory footprint and expressive power without introducing stochasticity. FPA generalizes several existing linear attention mechanisms, including Power Attention, and its factorized structure is amenable to efficient, hardware-friendly recurrent implementations with $O(L)$ complexity. We formally define the FPA kernel, analyze its invariant properties, and outline a path to efficient GPU execution, presenting a versatile framework for building powerful and scalable long-context transformers.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-02T07:01:49-07:00">
    <meta property="article:modified_time" content="2025-08-02T07:01:49-07:00">












<link rel="stylesheet" href="/assets/combined.min.92c3bf7119b98cfdc79e93f36a451eb901d8bbbfed7d75814e6436cf6c9085dc.css" media="all">











    




</head>







<body class="auto">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="http://localhost:1313/">A Nejati&#39;s blog</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/about" >
                /about
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/posts/">Posts</a><span class="breadcrumbs-separator">/</span>
        <a href="/posts/second-post/">Second Post</a></div>


<div >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">Second Post</h1>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="single-date">
              <time datetime="2025-08-02T07:01:49-07:00">August 2, 2025</time>
            </p>
          </div>
        </div>
        
    </header>
    
    <div class="single-content">
      <hr>
<h1 class="heading" id="finely-crafted-state-spaces-for-fast-attention">
  Finely Crafted State Spaces for Fast Attention
  <a class="anchor" href="#finely-crafted-state-spaces-for-fast-attention">#</a>
</h1>
<p><strong>Alireza Nejati</strong></p>
<h3 class="heading" id="abstract">
  Abstract
  <a class="anchor" href="#abstract">#</a>
</h3>
<p>Linear-time transformers have emerged as a promising solution to the quadratic cost of standard self-attention, but existing methods face a difficult trade-off. Stochastic approaches introduce variance, while deterministic polynomial kernels like Power Attention offer only coarse, exponential control over their state size, limiting their practicality. We introduce Factorized Polynomial Attention (FPA), a new attention mechanism that is both exact and offers fine-grained, continuous control over its state space. FPA constructs a degree-$n$ polynomial kernel by factorizing it into a product of $n$ inner products in lower-dimensional projected spaces. This formulation allows the state size to be adjusted by tuning the projection dimensions, smoothly navigating the trade-off between memory footprint and expressive power without introducing stochasticity. FPA generalizes several existing linear attention mechanisms, including Power Attention, and its factorized structure is amenable to efficient, hardware-friendly recurrent implementations with $O(L)$ complexity. We formally define the FPA kernel, analyze its invariant properties, and outline a path to efficient GPU execution, presenting a versatile framework for building powerful and scalable long-context transformers.</p>
<h2 class="heading" id="introduction">
  Introduction
  <a class="anchor" href="#introduction">#</a>
</h2>
<p>The ability of transformers to capture long‐range dependencies hinges on the $\Theta(L^2)$ cost of softmax self–attention, which becomes prohibitive once the context $L$ reaches millions of tokens [1]. Two broad strategies have emerged:</p>
<p><strong>Reducing the number of pairwise interactions.</strong> Examples include strided or windowed schemes [2, 3] and low–rank projections such as Linformer [4]. These methods preserve the softmax kernel but a persistent issue is degraded recall on tasks that require global context.</p>
<p><strong>Replacing the kernel itself.</strong> Linearized attention rewrites the softmax kernel as an inner product of feature maps $k(q,k)=\varphi(q)^{\top}\varphi(k)$, giving an $\Theta(L)$ recurrence [5]. Random–feature variants such as Performer’s $\mathrm{FAVOR}^+$ [6] are unbiased but introduce Monte‑Carlo variance that decays only as $\mathcal{O}(m^{-1/2})$ with the number $m$ of features. Deterministic kernels avoid variance but fix the memory footprint: Power attention [7] and its TPOW implementation require a $\binom{d+p-1}{p}$–sized state, which grows rapidly for $p&gt;2$.</p>
<p>Recent analyses [7, 8, 9] have framed the challenge for long-context models as a fundamental trade-off between recall capacity and inference throughput, governed by the model&rsquo;s recurrent state size. While standard attention excels at recall, its KV-cache grows linearly, making it memory-intensive. Conversely, efficient alternatives with fixed-size states often exhibit degraded performance on recall-intensive tasks.</p>
<p>A promising direction is to hybridize mechanisms: for instance, the BASED architecture [9] combines a degree-2 Taylor approximation of softmax for global context with local sliding-window attention for precision. This work introduces a significant generalization of this polynomial approach. We observe that the Taylor approximation is just one specific instance of a degree-2 polynomial kernel. In our approach, we provide a single, unified mechanism to navigate the state-size vs. recall Pareto frontier. By adjusting the projection dimensions ${d_\ell}$, our work offers a continuous memory knob to tune model capacity without resorting to stochastic methods or combining disparate architectural components. Furthermore, the FPA framework is compatible with hybrid designs, suggesting that its global, higher-order modeling capabilities can be complemented by local attention mechanisms to capture both long-range dependencies and fine-grained local interactions, forming a powerful new class of efficient transformers.</p>
<p><strong>Factorized Polynomial Attention (FPA).</strong> We propose¹ an exact kernel that expresses a degree‑$n$ polynomial as a product of $n$ lower‑dimensional dot products:
$$k_{\text{FPA}}(q,k)=\prod_{\ell=1}^{n}\bigl((W^{(\ell)}q)^{\top}(W^{(\ell)}k)\bigr)$$
where the branch widths $d_\ell$ are user‑specified. Setting $n=1$ recovers linear attention; $n=d$ and $W^{(\ell)}=I$ recover Power attention of order $d$. Between these extremes, $\sum_\ell d_\ell$ acts as a <strong>continuous memory knob</strong> with no stochastic error. In addition, if desired, additional parameters can be eliminated if $W^{(\ell)}$ are fixed blocks. The outer‑product update factorizes into $n$ standard GEMMs, enabling GPU/TPU fusion.</p>
<p>In this work, we introduce FPA, discuss various special cases, briefly discuss efficient implementation, and also discuss its relationship with other work. To our knowledge, no published method delivers an exact polynomial kernel with arbitrarily adjustable state that is amenable to the fast‑weight update. Works closest in spirit (product kernels [10], Kronecker attention [11], higher‑order transformers [12]) either maintain quadratic complexity in $L$ or fix the state width. We leave detailed evaluation of FPA on sequence modeling tasks to subsequent papers.</p>
<h2 class="heading" id="background">
  Background
  <a class="anchor" href="#background">#</a>
</h2>
<p>Our work builds upon the foundations of sequence modeling, primarily drawing from the Transformer architecture and its subsequent linear-time variants. We provide a brief overview of the concepts essential for understanding Factorized Polynomial Attention.</p>
<p><strong>Transformers and Self-Attention.</strong> At the core of the Transformer architecture [1] is the self-attention mechanism. Given a sequence of input embeddings represented by matrices for queries ($Q$), keys ($K$), and values ($V$), all in $\mathbb{R}^{L \times d}$ where $L$ is the sequence length and $d$ is the model dimension, standard self-attention computes the output matrix $O \in \mathbb{R}^{L \times d}$ as:
$$\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d}}\right)V$$</p>
<p><strong>Recurrent Neural Networks.</strong>
Recurrent Neural Networks (RNNs) offer a contrasting approach to sequence modeling. An RNN processes a sequence token-by-token, maintaining a fixed-size hidden state $h_t$ that evolves over time:
$$h_t = f(h_{t-1}, x_t)$$
where $x_t$ is the input at timestep $t$. This recurrent nature allows RNNs to operate with a computational cost that is linear in the sequence length, $O(L)$.</p>
<p><strong>Linear Attention.</strong>
Linear attention replaces the exponential kernel (softmax) in self-attention with a linear one. As shown by [5], this allows the attention mechanism to be expressed in both a parallel form for training and a recurrent form for efficient inference. Linear attention uses a feature map $\phi(\cdot)$ such that the attention output for a query $q_t$ can be written as:
$$o_t = \frac{\sum_{i=1}^{t} (\phi(q_t)^T \phi(k_i)) v_i}{\sum_{i=1}^{t} \phi(q_t)^T \phi(k_i)} = \frac{\phi(q_t)^T \sum_{i=1}^{t} \phi(k_i) v_i^T}{\phi(q_t)^T \sum_{i=1}^{t} \phi(k_i)}$$
By exploiting the associativity of matrix multiplication, and introducing causal masking, the sums can be computed incrementally. Letting $S_t = \sum_{i=1}^{t} \phi(k_i) v_i^T$ and $Z_t = \sum_{i=1}^{t} \phi(k_i)$, the state can be updated recurrently:
$$S_t = S_{t-1} + \phi(k_t)v_t^T \quad \text{and} \quad Z_t = Z_{t-1} + \phi(k_t)$$
This formulation achieves $O(Ld^2)$ complexity for parallel training and $O(L)$ for autoregressive inference, but with a state size of $O(d^2)$. However, the sequence modeling performance of simple linear attention often lags behind standard softmax attention, suggesting that the expressive power offered by the large state size of dot-product kernel is crucial.</p>
<p><strong>Power Attention.</strong> To enhance the expressiveness of linear attention, recent work has explored replacing the simple dot product with a polynomial kernel [7]. The output for power attention is defined as:
$$\mathrm{attn}_{\text{pow}}^{p}(Q, K, V)<em>i = \sum</em>{j=1}^{i}(Q_i^T K_j)^p V_j$$
Here, $Q_i$ and $K_j$ are vector representations from the query and key matrices, respectively.</p>
<p>This can be viewed as a specific instance of linear attention where the feature map $\phi(\cdot)$ is a tensorization of the input vector, mapping it to a much higher-dimensional space. Specifically, the tensorization is the <strong>TPOW operation</strong>, defined as follows.</p>
<p>For a vector $x \in \mathbb{R}^d$, its p-th tensor power, $x^{\otimes p}$, is a tensor of rank $p$. The TPOW operation flattens this tensor into a single vector in $\mathbb{R}^{d^p}$. The elements of this vector are all possible products of p elements from the original vector $x$:
$$
\mathrm{TPOW}<em>p(x) = \mathrm{flat}(x^{\otimes p}) =
\begin{bmatrix}
\vdots \
\prod</em>{k=1}^{p} x_{i_k} \
\vdots
\end{bmatrix}
\quad \text{for } (i_1, \dots, i_p) \in {1, \dots, d}^p
$$</p>
<p>A key mathematical property of the TPOW operation is that the inner product of the TPOW-transformed vectors $q$ and $k$ is equivalent to their original inner product raised to the p-th power:</p>
<p>$$
\mathrm{TPOW}_p(q)^T \mathrm{TPOW}_p(k) = (q^T k)^p
$$</p>
<p>This identity allows power attention to be framed as an instance of linear attention by setting the feature map $\phi = \mathrm{TPOW}_p$.</p>
<p>TPOW as described above contains many redundant entries (identical monomial terms) and unnecessary computation. In the same work ([7]), this drawback was identified, and a more optimized kernel (TSPOW) was suggested as a way of eliminating the redundancy by only retaining the (appropriately scaled) upper-triangular elements of the tensor of monomials. However, this becomes a distinct operation from TPOW and requires its own separate implementation.</p>
<p>Increasing dimensions causes the state space to grow exponentially. For instance, with $p=2$, the state size scales with $O(d^4)$, and for $p=3$, it scales with $O(d^6)$, significantly increasing the model&rsquo;s memory capacity. While powerful, this monolithic expansion can be computationally demanding and offers only coarse control over the state space size. Our work in this paper is directly motivated by the need for a more granular and efficient method to control the trade-off between model expressiveness and computational cost.</p>
<p>In the approach we introduce here, instead of taking the tensor product of the input vector with itself, we take the tensor product of multiple <em>projections</em> of the input vector into spaces of varying dimension. This offers a way to tune the state to any desired size while remaining exact and compatible with recursive implementations of linear/power attention-type with linear sequence length memory requirements.</p>
<h2 class="heading" id="factorized-polynomial-attention-fpa">
  Factorized Polynomial Attention (FPA)
  <a class="anchor" href="#factorized-polynomial-attention-fpa">#</a>
</h2>
<p>Here we formally describe FPA. FPA defines a kernel function by first projecting an input vector into several lower-dimensional spaces and then combining them with a product operation.</p>
<h3 class="heading" id="the-fpa-kernel">
  The FPA Kernel
  <a class="anchor" href="#the-fpa-kernel">#</a>
</h3>
<p>The kernel $\phi_{\text{FPA}}$ is constructed in two steps: a projection step and a product step.</p>
<p>First, an input vector $z \in \mathbb{R}^{d_{in}}$ is projected into $n$ separate feature vectors $z^{(1)}, z^{(2)}, \dots, z^{(n)}$ using distinct projection matrices. Each projection is defined as:
$$z^{(i)} = W^{(i)}z$$
where $W^{(i)} \in \mathbb{R}^{d_i \times d_{in}}$ is either a fixed or trainable weight matrix for the $i$-th projection, and the resulting vector $z^{(i)}$ has dimension $d_i$. Next, these projected vectors are combined using the Kronecker product ($\otimes$). The final feature map is the Kronecker product of all the projected vectors:</p>
<p>$$\phi_{\text{FPA}}(z) = z^{(1)} \otimes z^{(2)} \otimes \dots \otimes z^{(n)} = \bigotimes_{i=1}^{n} W^{(i)}z$$</p>
<p>The output is a vector in a high-dimensional space $\mathbb{R}^{D}$, where $D = \prod_{i=1}^{n} d_i$. In the case where $W^{(i)} = I$, this reduces to Power Attention with power $n$ and state space size $d^n$. As before, in the case where $n = 1$ and $W^{(1)}=I$, this reduces to standard linear attention. Importantly, by appropriate choice of $d_i$, we can finely tune the size of the state space.</p>
<p>An important note is that the projection matrices $W^{(i)}$ are unique to each attention head. Indeed, the matrices need not even have the same shape across different heads. We can make use of this property to show that the optimized TSPOW kernel is also a special case of FPA, see Appendix.</p>
<h3 class="heading" id="relationship-to-linear-attention">
  Relationship to Linear Attention
  <a class="anchor" href="#relationship-to-linear-attention">#</a>
</h3>
<p>A key basic property of the Kronecker product allows computing this kernel without explicitly constructing the state space, as with power attention. The inner product of two transformed vectors in the high-dimensional space simplifies to a product of inner products in the lower-dimensional projected spaces.</p>
<p>For two vectors $q$ and $k$:</p>
<p>$$
\begin{align*}
\phi_{\text{FPA}}(q)^T \phi_{\text{FPA}}(k) &amp;= \left(\bigotimes_{i=1}^{n} (W^{(i)}q)\right)^T \left(\bigotimes_{i=1}^{n} (W^{(i)}k)\right) \
&amp;= \prod_{i=1}^{n} \left( (W^{(i)}q)^T (W^{(i)}k) \right)
\end{align*}
$$</p>
<p>Substituting this into the linear attention framework gives the final formula for FPA:</p>
<p>$$
\mathrm{attn}<em>{\text{FPA}}(Q, K, V)<em>i = \sum</em>{j=1}^{i} \left( \prod</em>{l=1}^{n} ((W^{(l)}Q_i)^T (W^{(l)}K_j)) \right) V_j
$$</p>
<h3 class="heading" id="tunability-of-the-state-space">
  Tunability of the State Space
  <a class="anchor" href="#tunability-of-the-state-space">#</a>
</h3>
<p>FPA exposes two orthogonal knobs: <strong>Branch count</strong> $n$ (kernel degree) and <strong>branch widths</strong> ${d_k}$ (state size), tunable to any value between $d$ and $d^n$.</p>
<p>FPA has several advantages. It is exact but without blow-up, offering a deterministic kernel with a finely adjustable state size. Special cases of FPA, such as block‑identity or fixed orthogonal $W^{(k)}$ variants, add few or zero trainable parameters. It is hardware-friendly, with each branch being a standard GEMM; the outer product factorizes into $n$ small updates, compatible with tensor‑core pipelines, tensor‑train and sketch compression. The inductive bias provided by multiplicative feature interactions is useful for arithmetic, symbolic and some vision tasks.</p>
<h2 class="heading" id="invariant-properties-of-fpa">
  Invariant Properties of FPA
  <a class="anchor" href="#invariant-properties-of-fpa">#</a>
</h2>
<p>FPA inherits several algebraic symmetries from its construction. Understanding these invariances clarifies both its expressive biases and the kinds of transformations that can be absorbed without changing the attention scores.</p>
<ol>
<li>
<p><strong>Exchange symmetry.</strong> Because each factor in the FPA kernel is a symmetric bilinear form, the kernel satisfies $k_{\text{FPA}}(q,k)=k_{\text{FPA}}(k,q)$. Consequently, the attention operates on unordered pairs of tokens.</p>
</li>
<li>
<p><strong>Branch permutation symmetry.</strong> Multiplication is commutative, so permuting the list ${W^{(1)},\dots,W^{(n)}}$ leaves the kernel unchanged. This implies that networks need not track branch order, which simplifies implementation when $n$ is large.</p>
</li>
<li>
<p><strong>Common isometry group.</strong> Define the quadratic forms
$$
G^{(\ell)}=(W^{(\ell)})^{\top}W^{(\ell)}
$$
Let $\mathcal{G} = {U \in O(d_{\text{in}}) \mid U^{\top}G^{(\ell)}U=G^{(\ell)}; \forall \ell}$. Then $k_{\text{FPA}}(q,k)$ is invariant under simultaneous rotations $(q,k)\mapsto(Uq,Uk)$ for any $U\in\mathcal{G}$. When all $G^{(\ell)}$ are proportional to the identity, $\mathcal{G}$ equals the full orthogonal group and the kernel is isotropic; otherwise $\mathcal{G}$ shrinks to the intersection of the individual stabilizers.</p>
</li>
<li>
<p><strong>Scaling degeneracy.</strong> Re‑scaling a single projection $W^{(\ell)} \mapsto \alpha W^{(\ell)}$ multiplies the kernel by $\alpha^2$. A global renormalization therefore renders absolute scales irrelevant; only the relative norms across branches matter.</p>
</li>
<li>
<p><strong>Factor‑wise linearity.</strong> Holding all but one factor fixed, the kernel is linear in that factor. This separability is the key to its efficient fast‑weight implementation.</p>
</li>
</ol>
<h2 class="heading" id="special-cases-and-subfamilies-of-fpa">
  Special Cases and Sub‑Families of FPA
  <a class="anchor" href="#special-cases-and-subfamilies-of-fpa">#</a>
</h2>
<p>The general formulation admits numerous interesting sub-families that trade expressiveness against parameter count and invariance. Table 1 summarises some useful ones. As mentioned, Power attention and its TSPOW variant emerge as special cases of FPA, but other novel subtypes emerge as well, providing a large design space to explore.</p>
<p><strong>Table 1: Representative sub-families of FPA.</strong> All remain positive-definite kernels; each imposes different structural sparsity on the coefficient tensor.</p>

<div class="table-outer">
    <table>
        <thead>
            <tr>
                <th style="text-align: left"><strong>Name</strong></th>
                <th style="text-align: left"><strong>Constraint on $G^{(\ell)}$</strong></th>
                <th style="text-align: left"><strong>Implications</strong></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="text-align: left">Linear attention</td>
                <td style="text-align: left">$n = 1$</td>
                <td style="text-align: left">Original fast-weight kernel with $O(d)$ state.</td>
            </tr>
            <tr>
                <td style="text-align: left">Power attention</td>
                <td style="text-align: left">$n=p, W^{(\ell)} = I$</td>
                <td style="text-align: left">Homogeneous degree-$p$ kernel with $d^p$-sized state (TPOW).</td>
            </tr>
            <tr>
                <td style="text-align: left">Scaled-shared</td>
                <td style="text-align: left">$G^{(\ell)}=\alpha_\ell G_0$</td>
                <td style="text-align: left">Reduces to power attention up to a scalar; illustrates parameter redundancy.</td>
            </tr>
            <tr>
                <td style="text-align: left">Commuting set</td>
                <td style="text-align: left">$[G^{(\ell)},G^{(m)}]=0$</td>
                <td style="text-align: left">Separates direction vs. branch weighting; Simultaneously diagonalizable.</td>
            </tr>
            <tr>
                <td style="text-align: left">Diagonal factors</td>
                <td style="text-align: left">$G^{(\ell)}=\operatorname{diag}(g^{(\ell)})$</td>
                <td style="text-align: left">Monomials that never mix coordinates; feature map size $\prod_\ell d_\ell$.</td>
            </tr>
            <tr>
                <td style="text-align: left">Rank-1 factors</td>
                <td style="text-align: left">$G^{(\ell)}=a^{(\ell)}a^{(\ell)\top}$</td>
                <td style="text-align: left">Minimal-parameter degree-$n$ kernel acting along $n$ learned 1-D directions.</td>
            </tr>
            <tr>
                <td style="text-align: left">Orthogonal blocks</td>
                <td style="text-align: left">$\operatorname{tr}(G^{(\ell)}G^{(m)})=0$ for $\ell \neq m$</td>
                <td style="text-align: left">Independent sub-space interactions; useful for block-separable structure.</td>
            </tr>
            <tr>
                <td style="text-align: left">Projector factors</td>
                <td style="text-align: left">$G^{(\ell)2}=G^{(\ell)}$</td>
                <td style="text-align: left">Measures overlap inside $n$ chosen sub-spaces (idempotent).</td>
            </tr>
            <tr>
                <td style="text-align: left">Coordinate Select</td>
                <td style="text-align: left">$G^{(\ell)}=\operatorname{diag}(g^{(\ell)} \in {0, 1}^d)$</td>
                <td style="text-align: left">Parameter-free projection that forces interactions only between selected subsets of features. A sub-case of Diagonal and Projector factors.</td>
            </tr>
            <tr>
                <td style="text-align: left">TSPOW</td>
                <td style="text-align: left">fixed block-identity $W^{(\ell)}$</td>
                <td style="text-align: left">Eliminates monomial redundancy of TPOW while retaining exactness; obtained by setting mutually disjoint coordinate blocks.</td>
            </tr>
        </tbody>
    </table>
</div><p>Notably, some of the special cases lend themselves to highly efficient implementations. For instance, the Coordinate Select case can simply be rewritten as choosing a subset of elements of the input vector.</p>
<h2 class="heading" id="efficient-implementation">
  Efficient Implementation
  <a class="anchor" href="#efficient-implementation">#</a>
</h2>
<p>A naive implementation of FPA that explicitly materializes the high-dimensional feature maps $\phi_{\text{FPA}}(q)$ and $\phi_{\text{FPA}}(k)$ would not be feasible; the resulting vectors, of dimension $D = \prod_{i=1}^{n} d_i$, would incur prohibitive memory and I/O costs, creating a bottleneck that limits arithmetic intensity. This issue is analogous to the challenge posed by the intermediate $L \times L$ attention matrix in standard softmax attention. To overcome this, we adopt an I/O-aware approach inspired by FlashAttention [13] and its adaptation for Power Attention [7]. By fusing operations into a single GPU kernel, all intermediate computations can be performed on-chip in fast SRAM, avoiding costly reads and writes to HBM. The factorized structure of the FPA kernel is particularly amenable to this strategy. FPA can be implemented using two complementary strategies depending on sequence length.</p>
<p><strong>Parallel (Tiled) Form.</strong> For short to moderate sequence lengths, FPA is implemented as a single fused kernel that computes the attention output block-wise. The inputs $Q, K, V$ are tiled, and for each block of queries and keys, the kernel computes the FPA score matrix on-chip without forming the full $\phi_{\text{FPA}}$ vectors. Instead, it directly computes the product of inner products:
$$S_{\text{block}} = \prod_{\ell=1}^{n} \left( (W^{(\ell)}Q_{\text{block}})^T (W^{(\ell)}K_{\text{block}}) \right)$$
This involves $n$ independent, parallelizable matrix multiplications whose results are combined with an element-wise product reduction. The resulting score block is then used to compute the output, which is written back to HBM.</p>
<p><strong>Recurrent (Chunked) Form.</strong> For very long sequences, FPA&rsquo;s equivalence to linear attention permits a recurrent formulation with $O(L)$ complexity. We utilize a chunked parallel algorithm. The state update rule, $S_t = S_{t-1} + \phi_{\text{FPA}}(k_t)v_t^T$, is computed in segments. The outer product $\phi_{\text{FPA}}(k_t)v_t^T$ is computed efficiently by exploiting the Kronecker product structure of $\phi_{\text{FPA}}(k_t)$, again avoiding materialization of the high-dimensional state. This dual-formulation ensures that FPA can be implemented efficiently across all sequence length regimes, combining the parallelism of attention with the linear-time complexity of RNNs.</p>
<hr>
<h3 class="heading" id="footnotes">
  Footnotes
  <a class="anchor" href="#footnotes">#</a>
</h3>
<p>¹ Code at <code>github.com/anj1/fpa</code>.</p>
<hr>
<h2 class="heading" id="appendix">
  Appendix
  <a class="anchor" href="#appendix">#</a>
</h2>
<h3 class="heading" id="tspow-is-a-special-case-of-fpa">
  TSPOW is a special case of FPA
  <a class="anchor" href="#tspow-is-a-special-case-of-fpa">#</a>
</h3>
<p>Below we show that the <em>truncated symmetric power</em> (TSPOW) feature map of [7] of degree 2 can be reproduced exactly by an FPA kernel with two branches ($n=2$) and multiple heads, each head using a pair of carefully chosen (fixed, non-trained) linear projections $W^{(1)},W^{(2)}$.</p>
<h4 class="heading" id="degree2-tspow-block-size-b2">
  Degree‑2 TSPOW, block size $b=2$
  <a class="anchor" href="#degree2-tspow-block-size-b2">#</a>
</h4>
<p>Let the input be
$$x=[x_1,\dots,x_d]^{\top},\qquad d=mb;(m=\lceil d/2\rceil).$$
TSPOW keeps only the upper‑triangular monomials $x_i x_j$ with $i\le j$ and rescales mixed terms by $\sqrt{2}$:</p>

<div class="table-outer">
    <table>
        <thead>
            <tr>
                <th style="text-align: left">Kept Term</th>
                <th style="text-align: left">TSPOW Coefficient</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="text-align: left">$\lceil i/2\rceil = \lceil j/2\rceil$</td>
                <td style="text-align: left">1</td>
            </tr>
            <tr>
                <td style="text-align: left">$\lceil i/2\rceil &lt; \lceil j/2\rceil$</td>
                <td style="text-align: left">$\sqrt{2}$</td>
            </tr>
            <tr>
                <td style="text-align: left">$\lceil i/2\rceil &gt; \lceil j/2\rceil$</td>
                <td style="text-align: left">discarded</td>
            </tr>
        </tbody>
    </table>
</div><p><strong>Head construction:</strong>
For head $h \in {0, \dots, m-1}$ define its <em>anchor block</em>
$$S_h={2h+1, 2h+2}.$$
Then set two branch projections:</p>
<ul>
<li><strong>Branch $W^{(1)}_{h}$</strong>: $2 \times d$ matrix that selects entries in $S_h$ (identity on those, zeros elsewhere).</li>
<li><strong>Branch $W^{(2)}_{h}$</strong>: $d \times d$ matrix that keeps entries with index $\ge 2h+1$; multiplies the ones outside $S_h$ by $\sqrt{2}$; zeros everything with index $&lt;2h+1$.</li>
</ul>
<p>Formally, for column index $j$,
$$
W^{(2)}_{h}[j,j]=
\begin{cases}
1, &amp; j\in S_h\[2pt]
\sqrt{2}, &amp; j&gt;2h+2\[2pt]
0, &amp; j&lt;2h+1.
\end{cases}
$$
All off‑diagonal weights are 0, so each $W$ is just a diagonal mask.</p>
<p><strong>What each head contributes:</strong>
For any two vectors $q,k$
$$
k_{\text{FPA},h}(q,k)=
\bigl((W^{(1)}<em>{h}q)^{\top}(W^{(1)}</em>{h}k)\bigr);
\bigl((W^{(2)}<em>{h}q)^{\top}(W^{(2)}</em>{h}k)\bigr).
$$
Expanding the dot‑products shows that each head emits exactly the monomials $x_i x_i$ and $x_i x_j;(i&lt;j)$ with $i\in S_h, j\ge i$. Because terms with $j&lt;i$ are wiped out (their second factor is 0); and cross‑block terms get the desired $\sqrt{2}$ factor from $W^{(2)}<em>{h}$. Summing all heads $h=0,\dots,m-1$ therefore enumerates every upper‑triangular pair once with the correct coefficient. That is, the $\text{TSPOW}</em>{2 \times 2}$ feature map.</p>
<h4 class="heading" id="general-degree2-tspow-arbitrary-block-size-b">
  General degree‑2 TSPOW, arbitrary block size $b$
  <a class="anchor" href="#general-degree2-tspow-arbitrary-block-size-b">#</a>
</h4>
<p>Let blocks be contiguous chunks of length $b$:
$$S_h={hb+1,\dots,(h+1)b},\qquad h=0,\dots,m-1,;m=\lceil d/b\rceil.$$
Define per‑head projections:
$$
W^{(1)}<em>{h}: x \mapsto x|</em>{S_h}, \qquad
W^{(2)}_{h}: x_j \mapsto
\begin{cases}
x_j,&amp; j\in S_h,\
\sqrt{2},x_j,&amp; j&gt;(h+1)b,\
0,&amp; j&lt;(hb+1).
\end{cases}
$$
Again, head $h$ covers all pairs with (left) index in $S_h$ and right‑index $\ge$ that left index. The union over heads realizes the upper‑triangular mask of TSPOW.</p>
<h4 class="heading" id="sketch-for-higherdegree-tspow-p2">
  Sketch for higher‑degree TSPOW ($p&gt;2$)
  <a class="anchor" href="#sketch-for-higherdegree-tspow-p2">#</a>
</h4>
<p>TSPOW$<em>p$ keeps monomials $x</em>{i_1}\dots x_{i_p}$ with a sorted index tuple $i_1\le\dots\le i_p$ and scales by $\sqrt{\text{mult}}$. We can extend the previous construction as follows. Use $n=p$ branches in FPA. Enumerate all non‑decreasing block‑index tuples $(h_1\le\dots\le h_p)$. For each tuple create one head. For branch $r$ in that head, $W^{(r)}$ selects the $b$ coordinates of block $S_{h_r}$. Coordinates whose block index is greater than $h_r$ are multiplied by $\sqrt{p!/\text{mult}}$ in exactly enough branches to reproduce the TSPOW scaling.</p>
<p>This construction produces every sorted index tuple once (no duplicates) and applies the right combinatorial scaling, while preserving the factorised (linear‑time) structure of FPA.</p>
<h4 class="heading" id="remarks">
  Remarks
  <a class="anchor" href="#remarks">#</a>
</h4>
<p>Viewing TSPOW via FPA clarifies that many &ldquo;special&rdquo; polynomial kernels are just different block masks and scalings; they can therefore inherit the same hardware paths and optimisation tricks as generic FPA.</p>
<p>As stated before, however, this construction is only possible by choosing the projection matrices $W^{(i)}$ to have different shapes across different heads. In practice, this can complicate the implementation because different gpu threads will have to compute different branches, just as the implementation in [7] describes. There is no free lunch here; writing TSPOW in terms of FPA does not provide a free performant gpu implementation. Specialized code is still needed.</p>

    </div>
  </article>

  

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flexnowrap">

        <div class="single-pagination-prev">
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/posts/first-post/">
                        First Post
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    

    
    





    




    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  
  <link rel="stylesheet" 
  href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
  
<script defer 
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
